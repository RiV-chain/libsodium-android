/*
 * This file is part of libsodium-android.
 *
 * libsodium-android is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libsodium-android is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libsodium-android.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.rivchain.libsodium_java.interfaces;


import org.rivchain.libsodium_java.exceptions.SodiumException;
import org.rivchain.libsodium_java.utils.DetachedEncrypt;
import org.rivchain.libsodium_java.utils.Key;

public interface SecretBox {


    int XSALSA20POLY1305_KEYBYTES = 32,
        XSALSA20POLY1305_NONCEBYTES = 24,
        XSALSA20POLY1305_MACBYTES = 16;

    int KEYBYTES = XSALSA20POLY1305_KEYBYTES,
        MACBYTES = XSALSA20POLY1305_MACBYTES,
        NONCEBYTES = XSALSA20POLY1305_NONCEBYTES;


    interface Native {

        /**
         * Creates a random key. It is equivalent to calling
         * {@link Random#randomBytesBuf(int)} but improves code
         * clarity and can prevent misuse by ensuring
         * that the provided key length is
         * always correct.
         * @param key The key which is of size {@link #KEYBYTES}.
         */
        void cryptoSecretBoxKeygen(byte[] key);

        /**
         * Encrypts a message using a key generated by {@link #cryptoSecretBoxKeygen(byte[])}.
         * @param cipherText The cipher text. Should be at least {@link #MACBYTES} + {@code messageLen}.
         * @param message The message to encrypt.
         * @param messageLen The message byte array length.
         * @param nonce A nonce of size {@link #NONCEBYTES} generated by {@link Random#randomBytesBuf(int)}.
         * @param key The symmetric key generated by {@link #cryptoSecretBoxKeygen(byte[])}.
         * @return True if successful.
         */
        boolean cryptoSecretBoxEasy(byte[] cipherText,
                                 byte[] message,
                                 long messageLen,
                                 byte[] nonce,
                                 byte[] key);

        /**
         * Decrypts and verifies a message using a key generated
         * by {@link #cryptoSecretBoxKeygen(byte[])}.
         * @param message The message will be put into here once decrypted.
         * @param cipherText The cipher produced by {@link #cryptoSecretBoxEasy(byte[], byte[], long, byte[], byte[])}.
         * @param cipherTextLen The cipher text length.
         * @param nonce This has to be the same nonce that was used when
         *              encrypting using {@code cryptoSecretBoxEasy}.
         * @param key The key generated by {@link #cryptoSecretBoxKeygen(byte[])}.
         * @return True if successful.
         */
        boolean cryptoSecretBoxOpenEasy(byte[] message,
                                      byte[] cipherText,
                                      long cipherTextLen,
                                      byte[] nonce,
                                      byte[] key);

        /**
         * Encrypts a message. Alongside the cipher a mac is
         * returned which can be stored in separate locations.
         * @param cipherText The encrypted message of length {@code messageLen}.
         * @param mac The mac.
         * @param message The message to encrypt.
         * @param messageLen The message's length.
         * @param nonce A randomly generated nonce of size {@link #NONCEBYTES}. Use {@link Random#randomBytesBuf(int)}.
         * @param key The key generated by {@link #cryptoSecretBoxKeygen(byte[])}.
         * @return True if successful.
         */
        boolean cryptoSecretBoxDetached(byte[] cipherText,
                                     byte[] mac,
                                     byte[] message,
                                     long messageLen,
                                     byte[] nonce,
                                     byte[] key);

        /**
         * Decrypts a message with the mac and the cipher provided
         * separately.
         * @param message The message length which is the same size as {@code cipherTextLen}.
         * @param cipherText The cipher.
         * @param mac The mac.
         * @param cipherTextLen The cipher text length.
         * @param nonce The nonce that was used in {@link #cryptoSecretBoxDetached}.
         * @param key The key generated by {@link #cryptoSecretBoxKeygen(byte[])}.
         * @return True if successful.
         */
        boolean cryptoSecretBoxOpenDetached(byte[] message,
                                          byte[] cipherText,
                                          byte[] mac,
                                          long cipherTextLen,
                                          byte[] nonce,
                                          byte[] key);

    }

    interface Lazy {

        /**
         * Generates a secret symmetric key.
         * @return A secret symmetric key which has been through {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         *
         */
        Key cryptoSecretBoxKeygen();


        /**
         * Encrypts a message.
         * @param message The message to encrypt.
         * @param nonce A randomly generated nonce of size {@link #NONCEBYTES}. Use {@link Random#randomBytesBuf(int)}.
         * @param key The key. A hexadecimal string that's been through {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         * @return The cipher byte array that's been {@link Helpers.Lazy#sodiumBin2Hex(byte[])}'ified.
         */
        String cryptoSecretBoxEasy(String message, byte[] nonce, Key key) throws SodiumException;

        /**
         * Decrypts a message.
         * @param cipher The hexadecimal cipher text. See {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         * @param nonce The nonce that was used when you encrypted with {@link #cryptoSecretBoxEasy(String, byte[], Key)}.
         * @param key The key. A hexadecimal string that's been through {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         * @return The decrypted message.
         */
        String cryptoSecretBoxOpenEasy(String cipher, byte[] nonce, Key key) throws SodiumException;


        /**
         * Encrypts a message with the mac separately
         * @param message The message to encrypt.
         * @param nonce A randomly generated nonce of size {@link #NONCEBYTES}. Use {@link Random#randomBytesBuf(int)}.
         * @param key The key. A hexadecimal string that's been through {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         * @return The cipher byte array that's been {@link Helpers.Lazy#sodiumBin2Hex(byte[])}'ified.
         */
        DetachedEncrypt cryptoSecretBoxDetached(String message, byte[] nonce, Key key) throws SodiumException;

        /**
         * Decrypts a message.
         * @param cipherAndMac The hexadecimal cipher text. See {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         * @param nonce The nonce that was used when you encrypted with {@link #cryptoSecretBoxEasy(String, byte[], Key)}.
         * @param key The key. A hexadecimal string that's been through {@link Helpers.Lazy#sodiumBin2Hex(byte[])}.
         * @return The decrypted message.
         */
        String cryptoSecretBoxOpenDetached(DetachedEncrypt cipherAndMac, byte[] nonce, Key key) throws SodiumException;

    }


}
